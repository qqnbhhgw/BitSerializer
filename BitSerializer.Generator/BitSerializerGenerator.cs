using System.Collections.Immutable;
using System.Linq;
using System.Text;
using BitSerializer.Generator.Analysis;
using BitSerializer.Generator.Emitters;
using BitSerializer.Generator.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace BitSerializer.Generator;

[Generator]
public class BitSerializerGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var allResults = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "BitSerializer.BitSerializeAttribute",
                predicate: (node, _) => node is ClassDeclarationSyntax or StructDeclarationSyntax or RecordDeclarationSyntax,
                transform: (ctx, ct) => TypeAnalyzer.Analyze(ctx, ct));

        // Report diagnostics for non-partial types
        context.RegisterSourceOutput(allResults, (spc, result) =>
        {
            if (result is null) return;
            if (result.Diagnostic is not null)
            {
                spc.ReportDiagnostic(result.Diagnostic);
                return;
            }
            if (result.Model is null) return;
            var source = GeneratePartialClass(result.Model);
            var fileName = result.Model.FullyQualifiedName
                .Replace("global::", "")
                .Replace(".", "_")
                .Replace("+", "_")
                .Replace("<", "_")
                .Replace(">", "")
                .Replace(",", "_")
                .Replace(" ", "");
            spc.AddSource($"{fileName}.g.cs", source);
        });

        // Generate registry
        var validModels = allResults
            .Where(r => r?.Model is not null)
            .Select((r, _) => r!.Model);
        var allTypes = validModels.Collect();
        context.RegisterSourceOutput(allTypes, RegistryEmitter.Emit);
    }

    private static string GeneratePartialClass(TypeModel model)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        // sb.AppendLine($"// HasBase={model.HasBitSerializableBaseType} BaseBitLength={model.BaseBitLength} TotalBitLength={model.TotalBitLength} Fields={model.Fields.Count}");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(model.Namespace))
        {
            sb.AppendLine($"namespace {model.Namespace};");
            sb.AppendLine();
        }

        // Open containing types (for nested types)
        int nestingDepth = model.ContainingTypes.Count;
        foreach (var container in model.ContainingTypes)
        {
            var containerKeyword = GetTypeKeyword(container.IsClass, container.IsRecord);
            sb.AppendLine($"partial {containerKeyword} {container.Name}");
            sb.AppendLine("{");
        }

        var typeKeyword = GetTypeKeyword(model.IsClass, model.IsRecord);
        var indent = new string(' ', nestingDepth * 4);
        sb.AppendLine($"{indent}partial {typeKeyword} {model.TypeName} : global::BitSerializer.IBitSerializable");
        sb.AppendLine($"{indent}{{");

        // SerializeLSB
        sb.Append(SerializerEmitter.EmitMethod(model, "LSB"));
        sb.AppendLine();

        // SerializeMSB
        sb.Append(SerializerEmitter.EmitMethod(model, "MSB"));
        sb.AppendLine();

        // DeserializeLSB
        sb.Append(DeserializerEmitter.EmitMethod(model, "LSB"));
        sb.AppendLine();

        // DeserializeMSB
        sb.Append(DeserializerEmitter.EmitMethod(model, "MSB"));
        sb.AppendLine();

        // GetTotalBitLength
        var newKeyword = model.HasBitSerializableBaseType ? "new " : "";
        if (model.HasDynamicLength)
        {
            sb.AppendLine($"    public {newKeyword}int GetTotalBitLength()");
            sb.AppendLine("    {");
            EmitDynamicBitLength(sb, model);
            sb.AppendLine("    }");
        }
        else
        {
            sb.AppendLine($"    public {newKeyword}int GetTotalBitLength() => {model.TotalBitLength};");
        }

        sb.AppendLine($"{indent}}}");

        // Close containing types
        for (int i = nestingDepth - 1; i >= 0; i--)
        {
            var closeIndent = new string(' ', i * 4);
            sb.AppendLine($"{closeIndent}}}");
        }

        return sb.ToString();
    }

    private static string GetTypeKeyword(bool isClass, bool isRecord)
    {
        if (isRecord)
            return isClass ? "record class" : "record struct";
        return isClass ? "class" : "struct";
    }

    private static void EmitDynamicBitLength(StringBuilder sb, TypeModel model)
    {
        // Start with static portion
        int staticBits = 0;
        var dynamicParts = new System.Collections.Generic.List<string>();

        foreach (var field in model.Fields)
        {
            if (field.IsTypeParameter)
            {
                // Type parameter: bit length unknown at compile time, use interface dispatch
                dynamicParts.Add($"((global::BitSerializer.IBitSerializable)this.{field.MemberName}).GetTotalBitLength()");
            }
            else if (field.IsList && !field.FixedCount.HasValue)
            {
                // Dynamic list: count * elementBits
                dynamicParts.Add($"(int)this.{field.RelatedMemberName} * {field.ListElementBitLength}");
            }
            else if (field.IsList && field.FixedCount.HasValue)
            {
                staticBits += field.FixedCount.Value * field.ListElementBitLength;
            }
            else
            {
                staticBits += field.BitLength;
            }
        }

        var expr = staticBits.ToString();
        foreach (var part in dynamicParts)
        {
            expr += $" + {part}";
        }
        sb.AppendLine($"        return {expr};");
    }
}
